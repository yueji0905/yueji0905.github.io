<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>开学第一躺</title>
    <link href="/2025/02/17/6/"/>
    <url>/2025/02/17/6/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>指令</title>
    <link href="/2025/02/15/5/"/>
    <url>/2025/02/15/5/</url>
    
    <content type="html"><![CDATA[<h1 id="RSP-Stack-Pointer-Register"><a href="#RSP-Stack-Pointer-Register" class="headerlink" title="RSP(Stack Pointer Register):"></a>RSP(Stack Pointer Register):</h1><p>1.始终指向当前栈的顶部(最后入栈的数据的位置)</p><p>2.当执行push、pop、call、ret等指令时，RSP的值会自动变化。</p><h1 id="RBP（Base-Pointer-Register"><a href="#RBP（Base-Pointer-Register" class="headerlink" title="RBP（Base Pointer Register):"></a>RBP（Base Pointer Register):</h1><p>1.通常用作栈桢的基地址(指向当前的函数栈帧的起点)。</p><p>2.在函数执行中，RBP的值一般保持不变，方便通过偏移量访问局部变量或者参数。</p><p><code>mov rbp,rsp</code>的作用是将栈指针寄存器（RSP）的当前的之复制到基址寄存器(RBP)。(为当前函数建立一个固定的栈帧基址(RBP)，便于安全的管理局部变量和参数)</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">rbp</span>        <span class="hljs-comment">; 保存旧的 RBP 值到栈中</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">rbp</span>, <span class="hljs-built_in">rsp</span>   <span class="hljs-comment">; 将当前 RSP 的值（栈顶）赋给 RBP，作为新栈帧的基址</span><br><span class="hljs-keyword">sub</span> <span class="hljs-built_in">rsp</span>, N      <span class="hljs-comment">; 为局部变量分配空间（N 是字节数）</span><br>N=<span class="hljs-number">40h</span><br></code></pre></td></tr></table></figure><p><code>sub rsp,40h</code> 的作用是在站上分配64字节(十进制)的空间，通常用于储存函数的局部变量、临时数据，或为后续函数调用预留空间。这是函数调用建立栈帧的关键步骤之一。</p><h1 id="寄存器们"><a href="#寄存器们" class="headerlink" title="寄存器们"></a>寄存器们</h1><p>EAX（Accumulator Register）<br>累加器寄存器，常用于算术运算和返回值的存储。<br>EBX（Base Register）<br>基址寄存器，通常用于基址指针或存储在内存中的数据地址。<br>ECX（Counter Register）<br>计数寄存器，常用于循环操作或字符串操作中的计数。<br>EDX（Data Register）<br>数据寄存器，通常用于输入&#x2F;输出操作，也常与 EAX 一起使用处理乘法和除法操作。<br>ESI（Source Index）<br>源索引寄存器，常用于字符串操作或指向内存块的源地址。<br>EDI（Destination Index）<br>目标索引寄存器，常用于字符串操作或指向内存块的目标地址。<br>ESP（Stack Pointer）<br>栈指针寄存器，指向当前栈顶，管理函数调用时的堆栈。<br>EBP（Base Pointer）<br>基址指针寄存器，指向栈帧的基址，常用于存储调用函数时的栈帧信息。<br>EIP（Instruction Pointer）<br>指令指针寄存器，指向将要执行的下一条指令的地址。</p><p>xor   eax eax</p><h1 id="恢复栈空间"><a href="#恢复栈空间" class="headerlink" title="恢复栈空间"></a>恢复栈空间</h1><p>在函数结束时，必须恢复RSP的原始值，否则会导致栈不平衡。</p><p>1.常见操作</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">rsp</span>,<span class="hljs-built_in">rbp</span>  <span class="hljs-comment">;恢复RSP到分配之前的状态（RBP是旧的栈顶）</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">rbp</span>      <span class="hljs-comment">;恢复旧的RBP</span><br><span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><p>2.加法释放</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">add</span> <span class="hljs-built_in">rsp</span>, <span class="hljs-number">40h</span>  <span class="hljs-comment">;释放分配的64字节空间</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">rbp</span><br><span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><h1 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h1><p>段寄存器</p><p>在x86&#x2F;x64架构中，fs是段寄存器之一，用于访问线程特定的内存区域。</p><p>**Windows系统:**fs指向当前线程TIB，包括线程的异常处理链、栈信息等。</p><p>**Linux系统：<strong>fs可以用于</strong>线程局部存储(TLS)**或者其他内核数据结构。</p><h1 id="mov和lea"><a href="#mov和lea" class="headerlink" title="mov和lea"></a>mov和lea</h1><p>1.lea可以优化代码（他只计算地址而不涉及数据传输，再某种情况下可以减少内存访问次数）</p><p>​    mov涉及实际的数据复制，可能会增加内存访问次数</p><p>2.lea用于循环、数组操作和函数参数处理，因为他可以快速计算地址。</p><p>   mov用于一般的数据处理（变量处理、函数返回值）</p><h2 id="lea"><a href="#lea" class="headerlink" title="lea"></a>lea</h2><p>lea指令用于计算操作数的有效地址，并将其存储在寄存器里。不涉及实际的数据传输，只计算地址。</p><p>常用于获取数组、结构体或者变量地址，以及在寻呼那和数组操作中计算偏移地址。</p><p>eg：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">lea <span class="hljs-keyword">edi</span>, [lpBuffer] ; 将变量 lpBuffer 的地址加载到 <span class="hljs-keyword">edi</span> 寄存器中<br></code></pre></td></tr></table></figure><h2 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h2><p>用于将数据从一个位置移动到另一个位置、数据的粘贴复制。</p><p>可以移动立即数、寄存器中的值或内存中的数据。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, [lpBuffer] <span class="hljs-comment">; 将内存地址 lpBuffer 处的数据移动到 eax 寄存器中</span><br></code></pre></td></tr></table></figure><h1 id="Canary"><a href="#Canary" class="headerlink" title="Canary"></a>Canary</h1><p><strong>Canary 值</strong>（Stack Canary&#x2F;Cookie）是计算机安全中用于检测<strong>栈溢出攻击</strong>（Stack Buffer Overflow）的一种防御机制。它的核心思想是在栈的关键位置插入一个随机值，并在函数返回前验证该值是否被篡改。以下是关于 Canary 值的详细解析：</p><hr><h3 id="1-核心作用"><a href="#1-核心作用" class="headerlink" title="1. 核心作用"></a><strong>1. 核心作用</strong></h3><ul><li><strong>检测栈溢出</strong>：<br>Canary 值位于函数栈帧的返回地址之前。如果攻击者试图通过缓冲区溢出覆盖返回地址，会先破坏 Canary 值，从而触发安全检测。</li><li><strong>防止控制流劫持</strong>：<br>通过检测 Canary 值的完整性，阻止攻击者通过覆盖返回地址或函数指针来执行任意代码（如 ROP 攻击）。</li></ul><hr><h3 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a><strong>2. 工作原理</strong></h3><h4 id="2-1-函数执行时的工作流程"><a href="#2-1-函数执行时的工作流程" class="headerlink" title="2.1 函数执行时的工作流程"></a><strong>2.1 函数执行时的工作流程</strong></h4><ol><li><p><strong>函数序言（Prologue）</strong>：<br>在函数开始时，从线程安全区域（如 <code>fs:0x28</code>）读取 Canary 值，并将其插入栈的特定位置。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">fs</span>:<span class="hljs-number">0x28</span>     <span class="hljs-comment">; 读取 Canary 值到 rax</span><br><span class="hljs-keyword">mov</span>    [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">8</span>], <span class="hljs-built_in">rax</span>     <span class="hljs-comment">; 将 Canary 插入栈中</span><br></code></pre></td></tr></table></figure></li><li><p><strong>函数尾声（Epilogue）</strong>：<br>在函数返回前，检查栈中的 Canary 值是否与原始值一致。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rcx</span>, [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">8</span>]     <span class="hljs-comment">; 从栈中读取 Canary</span><br><span class="hljs-keyword">xor</span>    <span class="hljs-built_in">rcx</span>, <span class="hljs-built_in">fs</span>:<span class="hljs-number">0x28</span>     <span class="hljs-comment">; 与原始值比较</span><br><span class="hljs-keyword">jne</span>    stack_check_fail <span class="hljs-comment">; 不一致则终止程序</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="2-2-触发保护"><a href="#2-2-触发保护" class="headerlink" title="2.2 触发保护"></a><strong>2.2 触发保护</strong></h4><ul><li>如果攻击者通过缓冲区溢出覆盖了返回地址，<strong>必定会覆盖 Canary 值</strong>。</li><li>函数返回前的检查会发现 Canary 值被篡改，程序将立即终止（如调用 <code>__stack_chk_fail</code>）。</li></ul><hr><h3 id="3-Canary-值的类型"><a href="#3-Canary-值的类型" class="headerlink" title="3. Canary 值的类型"></a><strong>3. Canary 值的类型</strong></h3><h4 id="3-1-终结符-Canary（Terminator-Canary）"><a href="#3-1-终结符-Canary（Terminator-Canary）" class="headerlink" title="3.1 终结符 Canary（Terminator Canary）"></a><strong>3.1 终结符 Canary（Terminator Canary）</strong></h4><ul><li><strong>特点</strong>：使用包含 <code>0x00</code>、<code>0x0A</code>、<code>0x0D</code>、<code>0xFF</code> 等特殊字符的固定值（如 <code>0x000A0D00</code>）。</li><li><strong>防御场景</strong>：阻止基于字符串操作（如 <code>strcpy</code>）的溢出攻击，因为这些字符会终止字符串复制。</li><li><strong>缺点</strong>：容易被攻击者猜测或绕过。</li></ul><h4 id="3-2-随机-Canary（Random-Canary）"><a href="#3-2-随机-Canary（Random-Canary）" class="headerlink" title="3.2 随机 Canary（Random Canary）"></a><strong>3.2 随机 Canary（Random Canary）</strong></h4><ul><li><strong>特点</strong>：在程序启动时生成一个随机值，存储在全局区域（如 <code>fs:0x28</code>）。</li><li><strong>防御场景</strong>：每个进程的 Canary 值不同，防止攻击者通过内存泄漏获取。</li><li><strong>现代实现</strong>：主流操作系统（Linux、Windows）默认使用此类 Canary。</li></ul><h4 id="3-3-异或-Canary（XOR-Canary）"><a href="#3-3-异或-Canary（XOR-Canary）" class="headerlink" title="3.3 异或 Canary（XOR Canary）"></a><strong>3.3 异或 Canary（XOR Canary）</strong></h4><ul><li><strong>特点</strong>：将随机 Canary 值与栈上的其他数据（如返回地址）进行异或运算。</li><li><strong>防御场景</strong>：即使攻击者泄漏了 Canary 值，仍需知道异或的密钥才能构造有效载荷。</li><li><strong>复杂度</strong>：实现复杂，较少使用。</li></ul><hr><h3 id="4-Canary-的生成与存储"><a href="#4-Canary-的生成与存储" class="headerlink" title="4. Canary 的生成与存储"></a><strong>4. Canary 的生成与存储</strong></h3><h4 id="4-1-生成时机"><a href="#4-1-生成时机" class="headerlink" title="4.1 生成时机"></a><strong>4.1 生成时机</strong></h4><ul><li><strong>程序启动时</strong>：由操作系统或运行时库生成，存储在线程局部存储（TLS）中。<ul><li>例如，在 Linux 中，<code>glibc</code> 通过 <code>_dl_setup_stack_chk_guard</code> 初始化 Canary。</li></ul></li><li><strong>每次函数调用时</strong>：某些实现会动态生成 Canary（成本较高）。</li></ul><h4 id="4-2-存储位置"><a href="#4-2-存储位置" class="headerlink" title="4.2 存储位置"></a><strong>4.2 存储位置</strong></h4><ul><li><strong>x86-64 Linux</strong>：通过 <code>fs</code> 段寄存器访问，<code>fs:0x28</code> 存储 Canary。</li><li><strong>x86-64 Windows</strong>：类似，通过 <code>gs</code> 段寄存器访问。</li></ul><hr><h3 id="5-如何绕过-Canary？"><a href="#5-如何绕过-Canary？" class="headerlink" title="5. 如何绕过 Canary？"></a><strong>5. 如何绕过 Canary？</strong></h3><p>尽管 Canary 是有效的防护措施，但仍有潜在绕过方法：</p><h4 id="5-1-信息泄漏（Information-Leak）"><a href="#5-1-信息泄漏（Information-Leak）" class="headerlink" title="5.1 信息泄漏（Information Leak）"></a><strong>5.1 信息泄漏（Information Leak）</strong></h4><ul><li><strong>原理</strong>：通过漏洞（如格式化字符串漏洞）泄漏 Canary 值。</li><li><strong>防御</strong>：将 Canary 值存储在不可读的内存区域（现代系统已实现）。</li></ul><h4 id="5-2-覆盖其他指针"><a href="#5-2-覆盖其他指针" class="headerlink" title="5.2 覆盖其他指针"></a><strong>5.2 覆盖其他指针</strong></h4><ul><li><strong>原理</strong>：不覆盖返回地址，而是劫持函数指针或异常处理机制（如 SEH）。</li><li><strong>防御</strong>：结合其他防护（如 ASLR、CFG）。</li></ul><h4 id="5-3-逐字节爆破（Brute-Force）"><a href="#5-3-逐字节爆破（Brute-Force）" class="headerlink" title="5.3 逐字节爆破（Brute Force）"></a><strong>5.3 逐字节爆破（Brute Force）</strong></h4><ul><li><strong>原理</strong>：在 fork 型服务中，通过多次尝试猜测 Canary 值。</li><li><strong>防御</strong>：使用足够长的随机 Canary（如 64 位）。</li></ul><hr><h3 id="6-实际应用"><a href="#6-实际应用" class="headerlink" title="6. 实际应用"></a><strong>6. 实际应用</strong></h3><h4 id="6-1-编译器选项"><a href="#6-1-编译器选项" class="headerlink" title="6.1 编译器选项"></a><strong>6.1 编译器选项</strong></h4><ul><li><strong>GCC&#x2F;Clang</strong>：通过 <code>-fstack-protector</code> 启用 Canary（<code>-fno-stack-protector</code> 禁用）。</li><li><strong>MSVC</strong>：通过 <code>/GS</code> 编译选项启用。</li></ul><h4 id="6-2-检查是否启用-Canary"><a href="#6-2-检查是否启用-Canary" class="headerlink" title="6.2 检查是否启用 Canary"></a><strong>6.2 检查是否启用 Canary</strong></h4><p>在二进制中，可以通过以下特征识别：</p><ul><li><strong>函数序言</strong>：存在 <code>mov reg, fs:0x28</code> 指令。</li><li><strong>函数尾声</strong>：存在 <code>xor reg, fs:0x28</code> 和检查跳转。</li></ul><hr><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><strong>7. 总结</strong></h3><ul><li><strong>优点</strong>：高效、低开销，能防御大多数栈溢出攻击。</li><li><strong>缺点</strong>：无法防御堆溢出或非栈溢出漏洞。</li><li><strong>最佳实践</strong>：需结合其他防护（如 ASLR、DEP、CFI）。</li></ul><p>Canary 值是现代软件安全的基石之一，理解其原理对逆向工程、漏洞分析和防御设计至关重要。</p><h1 id="BSS、-data和-text"><a href="#BSS、-data和-text" class="headerlink" title=".BSS、.data和.text"></a>.BSS、.data和.text</h1><p><a href="https://blog.csdn.net/SXXYNHHXX/article/details/142489025?fromshare=blogdetail&sharetype=blogdetail&sharerId=142489025&sharerefer=PC&sharesource=2401_88035404&sharefrom=from_link">https://blog.csdn.net/SXXYNHHXX/article/details/142489025?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=142489025&amp;sharerefer=PC&amp;sharesource=2401_88035404&amp;sharefrom=from_link</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>happy~happy~happy~</title>
    <link href="/2025/02/07/3/"/>
    <url>/2025/02/07/3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hell0~</title>
    <link href="/2025/02/04/4/"/>
    <url>/2025/02/04/4/</url>
    
    <content type="html"><![CDATA[<h2 id="WUSTCTF2020-Cr0ssfun"><a href="#WUSTCTF2020-Cr0ssfun" class="headerlink" title="[WUSTCTF2020]Cr0ssfun"></a>[WUSTCTF2020]Cr0ssfun</h2><h2 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h2><p>64位ELF文件</p><p><img src="/2025/02/04/4/fun1.png"></p><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><p><img src="/2025/02/04/4/fun2.png"></p><p>分析可以知道将V4转化为64位整数类型，进入check函数，check函数的返回值被转化为unsigned int 类，如果返回值为1，输出Your flag is correct, go and submit it!</p><p>跟进check函数</p><p><img src="/2025/02/04/4/fun3.png"></p><p>继续跟进就ok了</p><p><img src="/2025/02/04/4/fun4.png"></p><p><img src="/2025/02/04/4/fun5.png"></p><p><img src="/2025/02/04/4/fun6.png"></p><p><img src="/2025/02/04/4/fun7.png"></p><p><img src="/2025/02/04/4/fun8.png"></p><p><img src="/2025/02/04/4/fun9.png"></p><p>按照下标将他们组合起来就得到flag<code>ctf2020&#123;cpp_@nd_r3verse_@re_fun&#125;</code></p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>感觉我做的好麻烦，去网上看看，同样很麻烦，顺了个没啥用的脚本</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs prolog">#include&lt;iostream&gt;<br>using namespace std;<br>int main()<br>&#123;<br>char a1[<span class="hljs-number">32</span>];<br>a1[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;c&#x27;</span>;a1[<span class="hljs-number">25</span>] =<span class="hljs-string">&#x27;@&#x27;</span> ; a1[<span class="hljs-number">27</span>] = <span class="hljs-string">&#x27;e&#x27;</span>;<br>  a1[<span class="hljs-number">4</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>      a1[<span class="hljs-number">17</span>] = <span class="hljs-string">&#x27;r&#x27;</span>;<br>       a1[<span class="hljs-number">29</span>] = <span class="hljs-string">&#x27;f&#x27;</span>;<br>       a1[<span class="hljs-number">17</span>]= <span class="hljs-string">&#x27;r&#x27;</span>;<br>       a1[<span class="hljs-number">24</span>] = <span class="hljs-string">&#x27;_&#x27;</span>;<br>       a1[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;t&#x27;</span>;<br>       a1[<span class="hljs-number">9</span>] = <span class="hljs-string">&#x27;c&#x27;</span>;<br>       a1[<span class="hljs-number">32</span>] = <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>       a1[<span class="hljs-number">19</span>] = <span class="hljs-string">&#x27;v&#x27;</span>;<br>       a1[<span class="hljs-number">5</span>] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>       a1[<span class="hljs-number">14</span>] = <span class="hljs-string">&#x27;n&#x27;</span>;<br>        a1[<span class="hljs-number">15</span>] = <span class="hljs-string">&#x27;d&#x27;</span>;<br>       a1[<span class="hljs-number">8</span>] =<span class="hljs-string">&#x27;&#123;&#x27;</span>;<br>       a1[<span class="hljs-number">18</span>] = <span class="hljs-string">&#x27;3&#x27;</span>;<br>       a1[<span class="hljs-number">28</span>] = <span class="hljs-string">&#x27;_&#x27;</span>;<br>       a1[<span class="hljs-number">21</span>] = <span class="hljs-string">&#x27;r&#x27;</span>;<br>        a1[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;w&#x27;</span>;<br>      a1[<span class="hljs-number">6</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>       a1[<span class="hljs-number">22</span>] = <span class="hljs-string">&#x27;s&#x27;</span>;<br>       a1[<span class="hljs-number">31</span>] = <span class="hljs-string">&#x27;n&#x27;</span>;<br>       a1[<span class="hljs-number">12</span>] = <span class="hljs-string">&#x27;_&#x27;</span>;<br>        a1[<span class="hljs-number">7</span>] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>       a1[<span class="hljs-number">16</span>] = <span class="hljs-string">&#x27;_&#x27;</span>;<br>       a1[<span class="hljs-number">11</span>] = <span class="hljs-string">&#x27;p&#x27;</span>;<br>       a1[<span class="hljs-number">23</span>] = <span class="hljs-string">&#x27;e&#x27;</span>;<br>       a1[<span class="hljs-number">30</span>] = <span class="hljs-string">&#x27;u&#x27;</span>;<br>    a1[<span class="hljs-number">10</span>] = <span class="hljs-string">&#x27;p&#x27;</span>;<br>       a1[<span class="hljs-number">13</span>] = <span class="hljs-string">&#x27;@&#x27;</span>;<br>       a1[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;f&#x27;</span>;<br>       a1[<span class="hljs-number">26</span>] = <span class="hljs-string">&#x27;r&#x27;</span>;<br>      a1[<span class="hljs-number">20</span>] = <span class="hljs-string">&#x27;e&#x27;</span>;<br>      for(int i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">32</span>;i++)cout &lt;&lt; a1[i];  <br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="UTCTF2020-basic-re"><a href="#UTCTF2020-basic-re" class="headerlink" title="[UTCTF2020]basic-re"></a>[UTCTF2020]basic-re</h1><h2 id="查壳-1"><a href="#查壳-1" class="headerlink" title="查壳"></a>查壳</h2><p>64位无壳文件</p><p><img src="/2025/02/04/4/base1.png"></p><h2 id="关键信息-反编译"><a href="#关键信息-反编译" class="headerlink" title="关键信息&amp;反编译"></a>关键信息&amp;反编译</h2><p>shift+F12查找字符串发现好多关键词，进去看看</p><p>得到mTyqm7wjODkrNLcWl0eqO8K8gc1BPk1GNLgUpI&#x3D;&#x3D;</p><p><code>base64Encode( )</code>进去看看吧</p><p><img src="/2025/02/04/4/base2.png"></p><p>base编码过程，从其中找到编码表</p><p><img src="/2025/02/04/4/base3.png"></p><p>AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0987654321&#x2F;+</p><p><img src="/2025/02/04/4/base4.png"></p><h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><p>把他们扔进CyberChef</p><p><img src="/2025/02/04/4/base5.png"></p><h1 id="GWCTF-2019-xxor"><a href="#GWCTF-2019-xxor" class="headerlink" title="[GWCTF 2019]xxor"></a>[GWCTF 2019]xxor</h1><h2 id="查壳-2"><a href="#查壳-2" class="headerlink" title="查壳"></a>查壳</h2><p>64位ELF文件</p><p><img src="/2025/02/04/4/xxor0.png"></p><h2 id="查找关键信息"><a href="#查找关键信息" class="headerlink" title="查找关键信息"></a>查找关键信息</h2><p>shift+F12查找关键字Congratulation!点进去看看吧</p><p><img src="/2025/02/04/4/xxor1.png"></p><h2 id="反编译-1"><a href="#反编译-1" class="headerlink" title="反编译"></a>反编译</h2><p>主要函数</p><p><code>sub_400770(v7, a2) = 1</code>输出成功信息</p><p><code>LODWORD(v7[j]) = dword_601078;</code>用于提取一个 64 位变量的低 32 位<br><code>HIDWORD(v7[j]) = dword_60107C;</code>用于提取一个 64 位变量的高 32 位</p><p><img src="/2025/02/04/4/xxor2.png"></p><p>深入sub_400686函数，发现只要获得其中需要的数据就可以逆向得到答案</p><p><img src="/2025/02/04/4/xxor3.png"></p><p>这是那个判断函数，从中就可以获得上面需要的信息</p><p><img src="/2025/02/04/4/xxor4.png"></p><p>用前几天学过的z3</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">from</span> z3 import *<br><span class="hljs-attribute">a1</span>=[<span class="hljs-number">0</span>]*<span class="hljs-number">6</span><br><span class="hljs-attribute">a1</span>[<span class="hljs-number">0</span>],a1[<span class="hljs-number">1</span>],a1[<span class="hljs-number">2</span>],a1[<span class="hljs-number">3</span>],a1[<span class="hljs-number">4</span>],a1[<span class="hljs-number">5</span>]=Ints(&#x27;a1[<span class="hljs-number">0</span>] a1[<span class="hljs-number">1</span>] a1[<span class="hljs-number">2</span>] a1[<span class="hljs-number">3</span>] a1[<span class="hljs-number">4</span>] a1[<span class="hljs-number">5</span>]&#x27;)<br><span class="hljs-attribute">s</span> = Solver()<br><span class="hljs-attribute">s</span>.add(a1[<span class="hljs-number">2</span>] - a1[<span class="hljs-number">3</span>]== <span class="hljs-number">2225223423</span>)<br><span class="hljs-attribute">s</span>.add(a1[<span class="hljs-number">3</span>] + a1[<span class="hljs-number">4</span>]== <span class="hljs-number">4201428739</span>)<br><span class="hljs-attribute">s</span>.add(a1[<span class="hljs-number">2</span>] - a1[<span class="hljs-number">4</span>]==<span class="hljs-number">1121399208</span>)<br><span class="hljs-attribute">s</span>.add(a1[<span class="hljs-number">0</span>] ==-<span class="hljs-number">548868226</span>)<br><span class="hljs-attribute">s</span>.add(a1[<span class="hljs-number">5</span>] == -<span class="hljs-number">2064448480</span>)<br><span class="hljs-attribute">s</span>.add(a1[<span class="hljs-number">1</span>] == <span class="hljs-number">550153460</span>)<br><span class="hljs-attribute">if</span> s.check()==sat:<br>    <span class="hljs-attribute">r</span>=s.model()<br><span class="hljs-attribute">print</span>(r)<br></code></pre></td></tr></table></figure><p>解密 ，然后再十六进制转化成字符串，得到flag</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a2[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a1[<span class="hljs-number">6</span>] = &#123; <span class="hljs-number">3746099070</span>,<span class="hljs-number">550153460</span>, <span class="hljs-number">3774025685</span> ,<span class="hljs-number">1548802262</span> ,<span class="hljs-number">2652626477</span> ,<span class="hljs-number">2230518816</span> &#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flag[<span class="hljs-number">6</span>];<br><span class="hljs-type">unsigned</span> v3, v4;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i,j;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; j+=<span class="hljs-number">2</span>)<br>&#123;<br>v3 = a1[j];<br>v4 = a1[j<span class="hljs-number">+1</span>];<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> tem = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span>)<span class="hljs-number">0x458BCD42</span> * <span class="hljs-number">64</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sum = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>) tem;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++)<br>&#123;<br>v4 -= (v3 + sum + <span class="hljs-number">20</span>) ^ ((v3 &lt;&lt; <span class="hljs-number">6</span>) + a2[<span class="hljs-number">2</span>]) ^ ((v3 &gt;&gt; <span class="hljs-number">9</span>) + a2[<span class="hljs-number">3</span>]) ^ <span class="hljs-number">16</span>;<br>v3 -= (v4 + sum + <span class="hljs-number">11</span>) ^ ((v4 &lt;&lt; <span class="hljs-number">6</span>) + a2[<span class="hljs-number">0</span>]) ^ ((v4 &gt;&gt; <span class="hljs-number">9</span>) + a2[<span class="hljs-number">1</span>]) ^ <span class="hljs-number">32</span>;<br>sum -= <span class="hljs-number">0x458BCD42</span>;<br>&#125;<br>flag[j] = v3;<br>flag[j + <span class="hljs-number">1</span>] = v4;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; n &lt; <span class="hljs-number">6</span>; n++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x&quot;</span>, flag[n]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h1><h2 id="1-ELF（Executable-and-Linkable-Format）"><a href="#1-ELF（Executable-and-Linkable-Format）" class="headerlink" title="1. ELF（Executable and Linkable Format）"></a><strong>1. ELF（Executable and Linkable Format）</strong></h2><ul><li><strong>使用平台</strong>：Linux、Unix、类Unix系统（如FreeBSD、Android）。</li><li><strong>特点</strong>：<ul><li>支持多种架构（如x86、ARM、RISC-V）。</li><li>支持动态链接和静态链接。</li><li>结构清晰，包含ELF头、程序头表、节头表。</li><li>常用于可执行文件、共享库（.so）、目标文件（.o）和核心转储。</li></ul></li><li><strong>工具</strong>：<code>readelf</code>、<code>objdump</code>、<code>nm</code>。</li><li><strong>文件扩展名</strong>：<code>.elf</code>、<code>.so</code>、<code>.o</code>。</li></ul><hr><h2 id="2-PE（Portable-Executable）"><a href="#2-PE（Portable-Executable）" class="headerlink" title="2. PE（Portable Executable）"></a><strong>2. PE（Portable Executable）</strong></h2><ul><li><strong>使用平台</strong>：Windows。</li><li><strong>特点</strong>：<ul><li>基于COFF（Common Object File Format）扩展。</li><li>支持32位（PE32）和64位（PE32+）。</li><li>包含DOS头、PE头、节表、导入表、导出表等。</li><li>支持动态链接（DLL文件）和资源管理（如图标、菜单）。</li></ul></li><li><strong>工具</strong>：<code>dumpbin</code>、<code>PEview</code>、<code>CFF Explorer</code>。</li><li><strong>文件扩展名</strong>：<code>.exe</code>、<code>.dll</code>、<code>.sys</code>。</li></ul><hr><h2 id="3-Mach-O（Mach-Object）"><a href="#3-Mach-O（Mach-Object）" class="headerlink" title="3. Mach-O（Mach Object）"></a><strong>3. Mach-O（Mach Object）</strong></h2><ul><li><strong>使用平台</strong>：macOS、iOS。</li><li><strong>特点</strong>：<ul><li>支持多种架构（如x86、ARM）。</li><li>包含Mach-O头、加载命令、段和节。</li><li>支持动态链接（dylib）和框架（Framework）。</li><li>支持代码签名和沙盒机制。</li></ul></li><li><strong>工具</strong>：<code>otool</code>、<code>nm</code>、<code>lipo</code>。</li><li><strong>文件扩展名</strong>：<code>.o</code>、<code>.dylib</code>、<code>.app</code>。</li></ul><h3 id="1-提取特定位"><a href="#1-提取特定位" class="headerlink" title="1. 提取特定位"></a>1. <strong>提取特定位</strong></h3><p>通过掩码操作，可以从数据中提取特定位。例如，提取一个字节的低4位：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">byte = <span class="hljs-number">0b10101100</span><br>mask = <span class="hljs-number">0b00001111</span><br>result = byte &amp; mask  # 结果为 <span class="hljs-number">0b00001100</span><br></code></pre></td></tr></table></figure><h3 id="2-设置特定位"><a href="#2-设置特定位" class="headerlink" title="2. 设置特定位"></a>2. <strong>设置特定位</strong></h3><p>掩码操作可以设置数据中的特定位。例如，设置一个字节的第3位：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">byte = <span class="hljs-number">0b10101100</span><br>mask = <span class="hljs-number">0b00000100</span><br>result = byte | mask  # 结果为 <span class="hljs-number">0b10101100</span><br></code></pre></td></tr></table></figure><h3 id="3-清除特定位"><a href="#3-清除特定位" class="headerlink" title="3. 清除特定位"></a>3. <strong>清除特定位</strong></h3><p>掩码操作可以清除数据中的特定位。例如，清除一个字节的第5位：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">byte = <span class="hljs-number">0b10101100</span><br>mask = ~<span class="hljs-number">0b00100000</span><br>result = byte &amp; mask  # 结果为 <span class="hljs-number">0b10001100</span><br></code></pre></td></tr></table></figure><h3 id="4-切换特定位"><a href="#4-切换特定位" class="headerlink" title="4. 切换特定位"></a>4. <strong>切换特定位</strong></h3><p>掩码操作可以切换数据中的特定位。例如，切换一个字节的第2位：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">byte = <span class="hljs-number">0b10101100</span><br>mask = <span class="hljs-number">0b00000010</span><br>result = byte ^ mask  # 结果为 <span class="hljs-number">0b10101110</span><br></code></pre></td></tr></table></figure><h3 id="5-检查特定位"><a href="#5-检查特定位" class="headerlink" title="5. 检查特定位"></a>5. <strong>检查特定位</strong></h3><p>掩码操作可以检查数据中的特定位是否被设置。例如，检查一个字节的第7位：</p><p>python</p><p>复制</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima">byte = <span class="hljs-number">0b10101100</span><br>mask = <span class="hljs-number">0b10000000</span><br><span class="hljs-keyword">if</span> byte &amp; mask:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第7位被设置&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第7位未被设置&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="6-组合掩码"><a href="#6-组合掩码" class="headerlink" title="6. 组合掩码"></a>6. <strong>组合掩码</strong></h3><p>多个掩码可以组合使用。例如，提取一个字节的第2位和第4位：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">byte = <span class="hljs-number">0b10101100</span><br>mask = <span class="hljs-number">0b00001010</span><br>result = byte &amp; mask  # 结果为 <span class="hljs-number">0b00001000</span><br></code></pre></td></tr></table></figure><h3 id="7-移位操作"><a href="#7-移位操作" class="headerlink" title="7. 移位操作"></a>7. <strong>移位操作</strong></h3><p>移位操作常与掩码操作结合使用。例如，提取一个32位整数的第5到第8位：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">value</span> = <span class="hljs-number">0</span>x12345678<br><span class="hljs-attr">mask</span> = <span class="hljs-number">0</span>x000000F0<br><span class="hljs-attr">result</span> = (value &amp; mask) &gt;&gt; <span class="hljs-number">4</span>  <span class="hljs-comment"># 结果为 0x00000005</span><br></code></pre></td></tr></table></figure><h1 id="Std库"><a href="#Std库" class="headerlink" title="Std库"></a>Std库</h1><h3 id="1-容器（Containers）"><a href="#1-容器（Containers）" class="headerlink" title="1. 容器（Containers）"></a><strong>1. 容器（Containers）</strong></h3><p>用于存储和管理数据的模板类，分为：</p><ul><li><strong>顺序容器</strong>：按顺序存储元素。<ul><li><code>vector</code>：动态数组。</li><li><code>list</code>：双向链表。</li><li><code>deque</code>：双端队列。</li><li><code>array</code>：固定大小数组（C++11）。</li><li><code>forward_list</code>：单向链表（C++11）。</li></ul></li><li><strong>关联容器</strong>：基于键值对的有序&#x2F;无序集合。<ul><li><code>set</code>&#x2F;<code>multiset</code>：有序唯一&#x2F;重复集合。</li><li><code>map</code>&#x2F;<code>multimap</code>：有序键值对。</li><li><code>unordered_set</code>&#x2F;<code>unordered_multiset</code>：哈希表实现的集合（C++11）。</li><li><code>unordered_map</code>&#x2F;<code>unordered_multimap</code>：哈希表实现的键值对（C++11）。</li></ul></li><li><strong>容器适配器</strong>：基于其他容器实现的接口。<ul><li><code>stack</code>：后进先出（LIFO）栈。</li><li><code>queue</code>：先进先出（FIFO）队列。</li><li><code>priority_queue</code>：优先级队列。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="2-算法（Algorithms）"><a href="#2-算法（Algorithms）" class="headerlink" title="2. 算法（Algorithms）"></a><strong>2. 算法（Algorithms）</strong></h3><p>提供通用算法，通过 <code>&lt;algorithm&gt;</code> 头文件访问：</p><ul><li><strong>非修改序列操作</strong>：<code>for_each</code>, <code>find</code>, <code>count</code>。</li><li><strong>修改序列操作</strong>：<code>copy</code>, <code>fill</code>, <code>replace</code>。</li><li><strong>排序和查找</strong>：<code>sort</code>, <code>binary_search</code>, <code>lower_bound</code>。</li><li><strong>数值操作</strong>：<code>accumulate</code>, <code>inner_product</code>（需 <code>&lt;numeric&gt;</code>）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br>std::<span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><hr><h3 id="3-字符串处理（Strings）"><a href="#3-字符串处理（Strings）" class="headerlink" title="3. 字符串处理（Strings）"></a><strong>3. 字符串处理（Strings）</strong></h3><ul><li><code>std::string</code>：动态字符串类，支持拼接、查找、替换等操作。</li><li><code>std::string_view</code>：字符串视图（C++17），用于高效读取字符串片段。</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;Hello&quot;</span>;<br>s.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot; World&quot;</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="4-输入-输出（I-O）"><a href="#4-输入-输出（I-O）" class="headerlink" title="4. 输入&#x2F;输出（I&#x2F;O）"></a><strong>4. 输入&#x2F;输出（I&#x2F;O）</strong></h3><p>通过 <code>&lt;iostream&gt;</code>、<code>&lt;fstream&gt;</code> 等头文件提供：</p><ul><li><strong>流对象</strong>：<code>std::cin</code>, <code>std::cout</code>, <code>std::cerr</code>, <code>std::clog</code>。</li><li><strong>文件操作</strong>：<code>std::ifstream</code>, <code>std::ofstream</code>。</li><li><strong>格式化工具</strong>：<code>std::hex</code>, <code>std::setw</code>, <code>std::fixed</code>（需 <code>&lt;iomanip&gt;</code>）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; <span class="hljs-number">42</span> &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><hr><h3 id="5-智能指针（Smart-Pointers）"><a href="#5-智能指针（Smart-Pointers）" class="headerlink" title="5. 智能指针（Smart Pointers）"></a><strong>5. 智能指针（Smart Pointers）</strong></h3><p>用于自动内存管理（需 <code>&lt;memory&gt;</code>）：</p><ul><li><code>std::unique_ptr</code>：独占所有权的指针。</li><li><code>std::shared_ptr</code>：共享所有权的指针。</li><li><code>std::weak_ptr</code>：解决 <code>shared_ptr</code> 循环引用问题。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> ptr = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="6-工具类与函数（Utilities）"><a href="#6-工具类与函数（Utilities）" class="headerlink" title="6. 工具类与函数（Utilities）"></a><strong>6. 工具类与函数（Utilities）</strong></h3><ul><li><strong>元编程</strong>：<code>std::pair</code>, <code>std::tuple</code>, <code>std::variant</code>（C++17）。</li><li><strong>类型操作</strong>：<code>std::move</code>（移动语义）, <code>std::forward</code>（完美转发）。</li><li><strong>时间和日期</strong>：<code>std::chrono</code>（需 <code>&lt;chrono&gt;</code>）。</li><li><strong>随机数生成</strong>：<code>std::mt19937</code>（需 <code>&lt;random&gt;</code>）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::pair&lt;<span class="hljs-type">int</span>, std::string&gt; p = &#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="7-多线程与并发（Concurrency）"><a href="#7-多线程与并发（Concurrency）" class="headerlink" title="7. 多线程与并发（Concurrency）"></a><strong>7. 多线程与并发（Concurrency）</strong></h3><p>通过 <code>&lt;thread&gt;</code>, <code>&lt;mutex&gt;</code>, <code>&lt;atomic&gt;</code> 等头文件支持：</p><ul><li>线程管理：<code>std::thread</code>, <code>std::jthread</code>（C++20）。</li><li>同步机制：<code>std::mutex</code>, <code>std::lock_guard</code>, <code>std::condition_variable</code>。</li><li>原子操作：<code>std::atomic&lt;T&gt;</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([]()&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Thread!&quot;</span>; &#125;)</span></span>;<br>t.<span class="hljs-built_in">join</span>();<br></code></pre></td></tr></table></figure><hr><h3 id="8-异常处理（Exceptions）"><a href="#8-异常处理（Exceptions）" class="headerlink" title="8. 异常处理（Exceptions）"></a><strong>8. 异常处理（Exceptions）</strong></h3><ul><li>异常类：<code>std::exception</code> 及其子类（如 <code>std::runtime_error</code>）。</li><li>异常工具：<code>std::throw_with_nested</code>（C++11）。</li></ul><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">throw</span> std::runtime_error(<span class="hljs-string">&quot;Error!&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">const</span> std::exception&amp; e) &#123;<br>    std::cerr &lt;&lt; e.what();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="9-其他重要组件"><a href="#9-其他重要组件" class="headerlink" title="9. 其他重要组件"></a><strong>9. 其他重要组件</strong></h3><ul><li><strong>函数对象</strong>：<code>std::function</code>（包装函数指针、Lambda 等）。</li><li><strong>正则表达式</strong>：<code>std::regex</code>（需 <code>&lt;regex&gt;</code>）。</li><li><strong>文件系统操作</strong>：<code>std::filesystem</code>（C++17，需 <code>&lt;filesystem&gt;</code>）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br>std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; add = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123; <span class="hljs-keyword">return</span> a + b; &#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>study</title>
    <link href="/2025/01/27/2/"/>
    <url>/2025/01/27/2/</url>
    
    <content type="html"><![CDATA[<h1 id="GDOUCTF-2023-Check-Your-Luck"><a href="#GDOUCTF-2023-Check-Your-Luck" class="headerlink" title="[GDOUCTF 2023]Check_Your_Luck"></a>[GDOUCTF 2023]Check_Your_Luck</h1><p><img src="/2025/01/27/2/z3%E6%B1%82%E8%A7%A30.png"></p><p>z3求解,第一次见查一查，挺简单的，写个脚本吧</p><p><img src="/2025/01/27/2/z3%E6%B1%82%E8%A7%A32.png"></p><h1 id="相册"><a href="#相册" class="headerlink" title="相册"></a>相册</h1><h2 id="APK文件，使用jadx-gui打开"><a href="#APK文件，使用jadx-gui打开" class="headerlink" title="APK文件，使用jadx-gui打开"></a>APK文件，使用jadx-gui打开</h2><h2 id="查找关键词邮箱-mail"><a href="#查找关键词邮箱-mail" class="headerlink" title="查找关键词邮箱(mail)"></a>查找关键词邮箱(mail)</h2><p>发现一个静态方法<code>sendMailByJavaMail</code>(用于通过 JavaMail API 发送电子邮件)</p><p><img src="/2025/01/27/2/%E7%9B%B8%E5%86%8C1.png"></p><p>右击查找用例</p><p><img src="/2025/01/27/2/%E7%9B%B8%E5%86%8C2.png"></p><p><img src="/2025/01/27/2/%E7%9B%B8%E5%86%8C3.png"></p><p>表示调用 <code>A2</code> 类中的静态方法 (判断：方法名前面有类名)<code>sendMailByJavaMail</code></p><p><img src="/2025/01/27/2/%E7%9B%B8%E5%86%8C4.png"></p><p>他接受了三个参数</p><p>该方法接受三个参数：</p><ol><li><code>C2.MAILSERVER</code>: 邮件服务器地址或配置。</li><li><code>&quot;通讯录(&quot; + tel + &quot;IMEI&quot; + imei + &quot;)&quot;</code>: 邮件的主题。</li><li><code>notebooks</code>: 邮件的内容。</li></ol><p>跟进MAILSERVER</p><p><img src="/2025/01/27/2/%E7%9B%B8%E5%86%8C5.png"></p><p>用loadlibrary函数，加载了core.so文件中的内容</p><p>base64关键字</p><p>跟进NativeMethod</p><p><img src="/2025/01/27/2/%E7%9B%B8%E5%86%8C6.png"></p><p>三个方法均返回字符串</p><h2 id="解压apk文件，访问libcore-so"><a href="#解压apk文件，访问libcore-so" class="headerlink" title="解压apk文件，访问libcore.so"></a>解压apk文件，访问libcore.so</h2><p>查壳，用IDA打开libcore.so</p><p>shift+F12查找关键信息</p><p>base64编码</p><p><img src="/2025/01/27/2/%E7%9B%B8%E5%86%8C7.png"></p><p>解码得到flag</p><p><img src="/2025/01/27/2/%E7%9B%B8%E5%86%8C9.png"></p><h1 id="BJDCTF-2020-JustRE"><a href="#BJDCTF-2020-JustRE" class="headerlink" title="[BJDCTF 2020]JustRE"></a>[BJDCTF 2020]JustRE</h1><h2 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h2><p><img src="/2025/01/27/2/justre1.png"></p><p>shift+F12查找关键词</p><p><img src="/2025/01/27/2/justre2.png"></p><p>好像，追踪</p><p><img src="/2025/01/27/2/justre3.png"></p><p>点击19999下给你flag,666这是要累死你，动态调试一下看看</p><p>嗯，他就是这个意思end</p><h1 id="Z3小知识"><a href="#Z3小知识" class="headerlink" title="Z3小知识"></a>Z3小知识</h1><p><img src="/2025/01/27/2/z3%E6%B1%82%E8%A7%A31.png"></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">from</span> z3 import *<br><span class="hljs-keyword">a</span>,b=Ints(<span class="hljs-string">&#x27;a b&#x27;</span>)<br>s=Solver() <span class="hljs-comment">#创建一个约束求解器</span><br>s.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">a</span>+b==<span class="hljs-number">10</span>) <span class="hljs-comment">#添加约束条件</span><br>s.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">a</span>+<span class="hljs-number">3</span>*b==<span class="hljs-number">12</span>)<br><br><span class="hljs-keyword">if</span> s.check()==sat: <span class="hljs-comment">#有解</span><br>    r=s.model() <span class="hljs-comment">#求解</span><br>print(r) <span class="hljs-comment">#[b = 1, a = 9]</span><br>print(r[<span class="hljs-keyword">a</span>]) <span class="hljs-comment">#9</span><br>print(r[b]) <span class="hljs-comment">#1</span><br><br></code></pre></td></tr></table></figure><h1 id="APK文件"><a href="#APK文件" class="headerlink" title="APK文件"></a>APK文件</h1><p>APK（Android Package）是 Android 应用程序的安装包文件格式。它包含了应用程序的所有代码、资源、配置文件等。</p><h2 id="APK-文件结构"><a href="#APK-文件结构" class="headerlink" title="APK 文件结构"></a><strong>APK 文件结构</strong></h2><p>APK 文件本质上是一个 ZIP 压缩包，包含以下主要文件和目录：</p><ul><li><strong><code>AndroidManifest.xml</code></strong>:<ul><li>应用程序的配置文件，定义了应用的基本信息（如包名、版本号、权限、组件等）。</li><li>使用二进制 XML 格式存储，需要通过工具（如 <code>apktool</code>）反编译后才能查看。</li></ul></li><li><strong><code>classes.dex</code></strong>:<ul><li>包含应用程序的 Java&#x2F;Kotlin 代码编译后的 Dalvik 字节码。</li><li>可能包含多个 <code>.dex</code> 文件（如 <code>classes2.dex</code>），用于支持多 Dex 文件的应用。</li></ul></li><li><strong><code>resources.arsc</code></strong>:<ul><li>编译后的资源索引表，存储了字符串、布局、样式等资源的映射关系。</li><li>通过资源 ID 快速定位资源。</li></ul></li><li><strong><code>res/</code></strong>:<ul><li>包含应用程序的资源文件（如图片、布局文件、字符串等）。</li><li>子目录包括 <code>drawable/</code>、<code>layout/</code>、<code>values/</code> 等。</li><li><strong><code>assets/</code></strong>:<ul><li>存放原始资源文件（如字体、配置文件等），不会被编译到 <code>resources.arsc</code> 中。</li><li>通过 <code>AssetManager</code> 访问。</li></ul></li><li><strong><code>lib/</code></strong>:<ul><li>包含应用程序的本地库（如 <code>.so</code> 文件），通常按 CPU 架构分类（如 <code>armeabi-v7a</code>、<code>arm64-v8a</code>）。</li></ul></li><li><strong><code>META-INF/</code></strong>:<ul><li>包含应用的签名信息，用于验证 APK 的完整性和来源。</li><li>主要文件：<ul><li><code>MANIFEST.MF</code>：列出所有文件的哈希值。</li><li><code>CERT.SF</code>：签名文件的哈希值。</li><li><code>CERT.RSA</code>：包含公钥和签名信息。</li></ul></li></ul></li></ul></li></ul><h2 id="APK-的反编译与修改"><a href="#APK-的反编译与修改" class="headerlink" title="APK 的反编译与修改"></a><strong>APK 的反编译与修改</strong></h2><ul><li><strong>反编译工具</strong>:<ul><li><code>apktool</code>：反编译 APK，提取资源和 <code>AndroidManifest.xml</code>。</li><li><code>dex2jar</code>：将 <code>.dex</code> 文件转换为 <code>.jar</code> 文件，便于查看 Java 代码。</li><li><code>JD-GUI</code>：查看 <code>.jar</code> 文件中的 Java 代码。</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>是逆向啊</title>
    <link href="/2025/01/23/heihei/"/>
    <url>/2025/01/23/heihei/</url>
    
    <content type="html"><![CDATA[<h1 id="HNCTF-2022-WEEK2-e-sy-flower"><a href="#HNCTF-2022-WEEK2-e-sy-flower" class="headerlink" title="[HNCTF 2022 WEEK2]e@sy_flower"></a>[HNCTF 2022 WEEK2]e@sy_flower</h1><h2 id="1-查壳选择合适IDA"><a href="#1-查壳选择合适IDA" class="headerlink" title="1.查壳选择合适IDA"></a>1.查壳选择合适IDA</h2><h2 id="2-发现去除花指令"><a href="#2-发现去除花指令" class="headerlink" title="2.发现去除花指令"></a>2.发现去除花指令</h2><h4 id="发现花指令"><a href="#发现花指令" class="headerlink" title="发现花指令"></a>发现花指令</h4><p>jnz+jz用连续两条相反的条件跳转，或是通过stc&#x2F;clc汇编指令来设置位，使条件跳转变为永真或者永假跳转</p><h4 id="将花指令nop"><a href="#将花指令nop" class="headerlink" title="将花指令nop"></a>将花指令nop</h4><p><img src="/2025/01/23/heihei/flower1.png" alt="flower1"></p><p>Edit-Patch program-Change bytes<br>将E9改为90<br><img src="/2025/01/23/heihei/flower2.png" alt="flower2"></p><h2 id="3-反编译"><a href="#3-反编译" class="headerlink" title="3.反编译"></a>3.反编译</h2><p>找到main函数，在main函数之前摁P重定义<br><img src="/2025/01/23/heihei/flower3.png" alt="flower3"><br>F5反编译<br><img src="/2025/01/23/heihei/flower4.png" alt="flower4"></p><h4 id="函数的分析"><a href="#函数的分析" class="headerlink" title="函数的分析"></a>函数的分析</h4><p>(1)Arglist中的字符两两交换位置（2n与2n+1交换）</p><p>(2)Arglist中的每个字符与字符’0’进行异或操作</p><h2 id="4-脚本"><a href="#4-脚本" class="headerlink" title="4.脚本"></a>4.脚本</h2><p><img src="/2025/01/23/heihei/flower5.png" alt="flower5"><br>嘿嘿嘿得到flag</p><h1 id="LitCTF-2023-ez-XOR"><a href="#LitCTF-2023-ez-XOR" class="headerlink" title="[LitCTF 2023]ez_XOR"></a>[LitCTF 2023]ez_XOR</h1><h2 id="1-查壳选IDA"><a href="#1-查壳选IDA" class="headerlink" title="1.查壳选IDA"></a>1.查壳选IDA</h2><h2 id="2-寻找关键字符"><a href="#2-寻找关键字符" class="headerlink" title="2.寻找关键字符"></a>2.寻找关键字符</h2><h4 id="shift-F12"><a href="#shift-F12" class="headerlink" title="shift+F12"></a>shift+F12</h4><p>发现关键字并追踪<br><img src="/2025/01/23/heihei/ez_xor0.png" alt="ez_xor0"></p><h2 id="3-反编译-1"><a href="#3-反编译-1" class="headerlink" title="3.反编译"></a>3.反编译</h2><p><img src="/2025/01/23/heihei/ez_xor.png" alt="ez_xor"><br>并不是到此处就可以直接写脚本了，点击XOR发现里面还有玄机<br><img src="/2025/01/23/heihei/ez_xor1.png" alt="ez_xor1"><br>好了，现在可以写脚本了</p><h2 id="4-脚本-1"><a href="#4-脚本-1" class="headerlink" title="4.脚本"></a>4.脚本</h2><p><img src="/2025/01/23/heihei/ez_xor2.png" alt="ez_xor2"></p><h1 id="花指令的小知识"><a href="#花指令的小知识" class="headerlink" title="花指令的小知识"></a>花指令的小知识</h1><h2 id="形式一"><a href="#形式一" class="headerlink" title="形式一:"></a>形式一:</h2><p>如果我们插入的花指令是一个操作码，那么后面程序原本的机器码就会被误认为是这个操作码的操作数，从而导致反汇编引擎的解析错误。</p><h2 id="形式二："><a href="#形式二：" class="headerlink" title="形式二："></a>形式二：</h2><p>插入的花指令也可以是改变堆栈平衡的汇编代码，跟形式一相同在这些花指令上面写上跳转指令，虽然花指令不会被执行，但是IDA进行解析时会认为该函数堆栈不平衡，从而使F5功能失效</p><h1 id="保持堆栈的平衡"><a href="#保持堆栈的平衡" class="headerlink" title="保持堆栈的平衡"></a>保持堆栈的平衡</h1><p>push ebp —  -把基址指针寄存器压入堆栈<br>pop ebp —-把基址指针寄存器弹出堆栈<br>push eax —-把数据寄存器压入堆栈<br>pop eax —-把数据寄存器弹出堆栈<br>nop —–不执行<br>add esp,1—–指针寄存器加1<br>sub esp,-1—–指针寄存器加1<br>add esp,-1——–指针寄存器减1<br>sub esp,1—–指针寄存器减1<br>inc ecx —–计数器加1<br>dec ecx —–计数器减1<br>sub esp,1 —-指针寄存器-1<br>sub esp,-1—-指针寄存器加1<br>jmp 入口地址—-跳到程序入口地址<br>push 入口地址—把入口地址压入堆栈<br>retn —— 反回到入口地址,效果与jmp 入口地址一样<br>mov eax,入口地址 ——把入口地址转送到数据寄存器中.<br>jmp eax —– 跳到程序入口地址<br>jb 入口地址<br>jnb 入口地址 ——效果和jmp 入口地址一样,直接跳到程序入口地址<br>xor eax,eax 寄存器EAX清0<br>CALL 空白命令的地址 无效call</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/01/16/hello-world/"/>
    <url>/2025/01/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
