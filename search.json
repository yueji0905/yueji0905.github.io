[{"title":"BaseCTF","url":"/2025/05/04/6/","content":"\n# Ez Xor\n\nmain函数\n\n```\n _main(argc, argv, envp);\n  memset(v14, 0, sizeof(v14));\n  v15 = 0;\n  v16 = 0;\n  *Str = 0x1D0B2D2625050901i64;\n  v11 = 0x673D491E20317A24i64;\n  v12 = 0x34056E2E2508504Di64;\n  strcpy(v13, \"\\\"@;%\");\n  *v5 = 0i64;\n  v6 = 0i64;\n  v7 = 0i64;\n  v8 = 0;\n  v9 = 0;\n  v4 = 0x726F58;\n  v18 = strlen(Str);\n  printf(\"Please input Your answer:\");\n  scanf(\"%s\", v5);\n  v17 = strlen(v5);\n  if ( v17 == 28 )\n  {\n    KeyStream(&v4, v14, 28);\n    encrypt(v14, v5, v17);\n    if ( CheckFlag(v5, Str, v18) )\n      printf(\"You are good!\");\n    else\n      printf(\"It's not flag!\");\n    return 1;\n  }\n  else\n  {\n    printf(\"Length was wrong！\");\n    return 0;\n  }\n}\n```\n\nKeyStream\n\n```\n for ( i = 0; i < a3; ++i )\n    *(a2 + i) = i ^ *(a1 + i % 3);\n  return 1i64;\n```\n\nencrypt\n\n```\n for ( i = 0; i < len; ++i )\n    *(data + i) ^= *(len - i - 1i64 + key);\n  return 1i64;\n```\n\n解密脚本\n\n```\nstr1= bytes.fromhex(\"01090525262D0B1D247A31201E493D674D5008252E6E053422403B25\")\nv4=[0x58,0x6F,0x72]\nflag=[]\nkey=[]\nfor i in range(0,28,+1):\n    key.append(i^v4[i%3])\nfor i in range(len(str1)):\n    flag.append(str1[i]^key[len(key)-i-1])\n    print(chr(flag[i]),end='')\n```\n\n## \n\n# 世界上最简单的题目\n\n```\n# #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n# #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n# #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n# #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n# #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\na1 =[1 ,1 ,1 ,3 ,1 ,1 ,1 ,3 ,1 ,1 ,1 ,3 ,1 ,1 ,3 ,1 ,1 ,3 ,1 ,1 ,3 ,1 ,3 ,1 ,3 ,1 ,3 ]#line:6\nf1 =[101 ,102 ,117 ,120 ,119 ,108 ,102 ,124 ,100 ,109 ]#line:7\ndef o1 ():#line:13\n# #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n# #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n# #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n# #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n# #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n    return input (\"please input your flag: \")#line:14\ndef p1 (O0O0OOOOO00OOOOO0 ):#line:20\n    return list (O0O0OOOOO00OOOOO0 )#line:21\ndef main ():#line:27\n    OO0O0O00O00O00OO0 =o1 ()#line:28\n    O0OOOO0O0O0O0OOOO =1 #line:29\n    # #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n# #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n# #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n# #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n# #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n    O00OOO0OO0000OO00 =0 #line:30\n    if len (OO0O0O00O00O00OO0 )!=len (f1 ):#line:36\n        print (\"Input length does not match.\")#line:37\n        exit ()#line:38\n    OOO00OOO0000OO0O0 =p1 (OO0O0O00O00O00OO0 )#line:44\n    # #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n# #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n# #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n# #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n# #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n    for O0O0OOO00O000000O in range (len (a1 )):#line:50\n        if a1 [O0O0OOO00O000000O ]==1 :#line:51\n            OOO00OOO0000OO0O0 [O00OOO0OO0000OO00 ]=chr (ord (OOO00OOO0000OO0O0 [O00OOO0OO0000OO00 ])^O0OOOO0O0O0O0OOOO )#line:57\n            O0OOOO0O0O0O0OOOO +=1 #line:58\n        elif a1 [O0O0OOO00O000000O ]==3 :#line:59\n            O00OOO0OO0000OO00 +=1 #line:60\n    for O0OOOOOO000000OOO in range (len (f1 )):#line:66\n        if f1 [O0OOOOOO000000OOO ]!=ord (OOO00OOO0000OO0O0 [O0OOOOOO000000OOO ]):#line:67\n            print (\"nooooo\")#line:68\n            # #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n# #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n# #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n# #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n# #免费的50分，复制粘贴直接秒杀！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n            exit ()#line:69\n    print (\"yes, your flag is\")#line:75\n    print (\"BaseCTF{\"+''.join (OO0O0O00O00O00OO0 )+\"}\")#line:76\nif __name__ ==\"__main__\":#line:82\n    main ()#line:83\t\n```\n\n解密代码\n\n```\nf1 = list('efuxwlf|dm')\na1 = [1,1,1,3,1,1,1,3,1,1,1,3,1,1,3,1,1,3,1,1,3,1,3,1,3,1,3]\nflag = []\na = 1\nb = 0\n\nfor i in a1:\n    if i == 1:\n        f1[b] = chr(ord(f1[b]) ^ a)\n        a += 1\n    elif i == 3:\n        b += 1\nfor i in range(len(f1)):\n     print(f1[i],end='')\n```\n\n"},{"title":"指令","url":"/2025/02/15/5/","content":"\n# RSP(Stack Pointer Register):\n\n1.始终指向当前栈的顶部(最后入栈的数据的位置)\n\n2.当执行push、pop、call、ret等指令时，RSP的值会自动变化。\n\n# RBP（Base Pointer Register):\n\n1.通常用作栈桢的基地址(指向当前的函数栈帧的起点)。\n\n2.在函数执行中，RBP的值一般保持不变，方便通过偏移量访问局部变量或者参数。\n\n``mov rbp,rsp``的作用是将栈指针寄存器（RSP）的当前的之复制到基址寄存器(RBP)。(为当前函数建立一个固定的栈帧基址(RBP)，便于安全的管理局部变量和参数)\n\n```\npush rbp        ; 保存旧的 RBP 值到栈中\nmov rbp, rsp   ; 将当前 RSP 的值（栈顶）赋给 RBP，作为新栈帧的基址\nsub rsp, N      ; 为局部变量分配空间（N 是字节数）\nN=40h\n```\n\n``sub rsp,40h`` 的作用是在站上分配64字节(十进制)的空间，通常用于储存函数的局部变量、临时数据，或为后续函数调用预留空间。这是函数调用建立栈帧的关键步骤之一。\n\n# 寄存器们\n\nEAX（Accumulator Register）\n累加器寄存器，常用于算术运算和返回值的存储。\nEBX（Base Register）\n基址寄存器，通常用于基址指针或存储在内存中的数据地址。\nECX（Counter Register）\n计数寄存器，常用于循环操作或字符串操作中的计数。\nEDX（Data Register）\n数据寄存器，通常用于输入/输出操作，也常与 EAX 一起使用处理乘法和除法操作。\nESI（Source Index）\n源索引寄存器，常用于字符串操作或指向内存块的源地址。\nEDI（Destination Index）\n目标索引寄存器，常用于字符串操作或指向内存块的目标地址。\nESP（Stack Pointer）\n栈指针寄存器，指向当前栈顶，管理函数调用时的堆栈。\nEBP（Base Pointer）\n基址指针寄存器，指向栈帧的基址，常用于存储调用函数时的栈帧信息。\nEIP（Instruction Pointer）\n指令指针寄存器，指向将要执行的下一条指令的地址。\n\nxor   eax eax\n\n# 恢复栈空间\n\n在函数结束时，必须恢复RSP的原始值，否则会导致栈不平衡。\n\n1.常见操作\n\n```\nmov rsp,rbp  ;恢复RSP到分配之前的状态（RBP是旧的栈顶）\npop rbp      ;恢复旧的RBP\nret\n```\n\n2.加法释放\n\n```\nadd rsp, 40h  ;释放分配的64字节空间\npop rbp\nret\n```\n\n# fs\n\n段寄存器\n\n在x86/x64架构中，fs是段寄存器之一，用于访问线程特定的内存区域。\n\n**Windows系统:**fs指向当前线程TIB，包括线程的异常处理链、栈信息等。\n\n**Linux系统：**fs可以用于**线程局部存储(TLS)**或者其他内核数据结构。\n\n# mov和lea\n\n1.lea可以优化代码（他只计算地址而不涉及数据传输，再某种情况下可以减少内存访问次数）\n\n​    mov涉及实际的数据复制，可能会增加内存访问次数\n\n2.lea用于循环、数组操作和函数参数处理，因为他可以快速计算地址。\n\n   mov用于一般的数据处理（变量处理、函数返回值）\n\n## lea\n\nlea指令用于计算操作数的有效地址，并将其存储在寄存器里。不涉及实际的数据传输，只计算地址。\n\n常用于获取数组、结构体或者变量地址，以及在寻呼那和数组操作中计算偏移地址。\n\neg：\n\n```\nlea edi, [lpBuffer] ; 将变量 lpBuffer 的地址加载到 edi 寄存器中\n```\n\n## mov\n\n用于将数据从一个位置移动到另一个位置、数据的粘贴复制。\n\n可以移动立即数、寄存器中的值或内存中的数据。\n\n```\nmov eax, [lpBuffer] ; 将内存地址 lpBuffer 处的数据移动到 eax 寄存器中\n```\n\n\n\n# Canary\n\n**Canary 值**（Stack Canary/Cookie）是计算机安全中用于检测**栈溢出攻击**（Stack Buffer Overflow）的一种防御机制。它的核心思想是在栈的关键位置插入一个随机值，并在函数返回前验证该值是否被篡改。以下是关于 Canary 值的详细解析：\n\n------\n\n### **1. 核心作用**\n\n- **检测栈溢出**：\n  Canary 值位于函数栈帧的返回地址之前。如果攻击者试图通过缓冲区溢出覆盖返回地址，会先破坏 Canary 值，从而触发安全检测。\n- **防止控制流劫持**：\n  通过检测 Canary 值的完整性，阻止攻击者通过覆盖返回地址或函数指针来执行任意代码（如 ROP 攻击）。\n\n------\n\n### **2. 工作原理**\n\n#### **2.1 函数执行时的工作流程**\n\n1. **函数序言（Prologue）**：\n   在函数开始时，从线程安全区域（如 `fs:0x28`）读取 Canary 值，并将其插入栈的特定位置。\n\n   ```\n   mov    rax, fs:0x28     ; 读取 Canary 值到 rax\n   mov    [rbp-8], rax     ; 将 Canary 插入栈中\n   ```\n\n2. **函数尾声（Epilogue）**：\n   在函数返回前，检查栈中的 Canary 值是否与原始值一致。\n\n   ```\n   mov    rcx, [rbp-8]     ; 从栈中读取 Canary\n   xor    rcx, fs:0x28     ; 与原始值比较\n   jne    stack_check_fail ; 不一致则终止程序\n   ```\n\n#### **2.2 触发保护**\n\n- 如果攻击者通过缓冲区溢出覆盖了返回地址，**必定会覆盖 Canary 值**。\n- 函数返回前的检查会发现 Canary 值被篡改，程序将立即终止（如调用 `__stack_chk_fail`）。\n\n------\n\n### **3. Canary 值的类型**\n\n#### **3.1 终结符 Canary（Terminator Canary）**\n\n- **特点**：使用包含 `0x00`、`0x0A`、`0x0D`、`0xFF` 等特殊字符的固定值（如 `0x000A0D00`）。\n- **防御场景**：阻止基于字符串操作（如 `strcpy`）的溢出攻击，因为这些字符会终止字符串复制。\n- **缺点**：容易被攻击者猜测或绕过。\n\n#### **3.2 随机 Canary（Random Canary）**\n\n- **特点**：在程序启动时生成一个随机值，存储在全局区域（如 `fs:0x28`）。\n- **防御场景**：每个进程的 Canary 值不同，防止攻击者通过内存泄漏获取。\n- **现代实现**：主流操作系统（Linux、Windows）默认使用此类 Canary。\n\n#### **3.3 异或 Canary（XOR Canary）**\n\n- **特点**：将随机 Canary 值与栈上的其他数据（如返回地址）进行异或运算。\n- **防御场景**：即使攻击者泄漏了 Canary 值，仍需知道异或的密钥才能构造有效载荷。\n- **复杂度**：实现复杂，较少使用。\n\n------\n\n### **4. Canary 的生成与存储**\n\n#### **4.1 生成时机**\n\n- **程序启动时**：由操作系统或运行时库生成，存储在线程局部存储（TLS）中。\n  - 例如，在 Linux 中，`glibc` 通过 `_dl_setup_stack_chk_guard` 初始化 Canary。\n- **每次函数调用时**：某些实现会动态生成 Canary（成本较高）。\n\n#### **4.2 存储位置**\n\n- **x86-64 Linux**：通过 `fs` 段寄存器访问，`fs:0x28` 存储 Canary。\n- **x86-64 Windows**：类似，通过 `gs` 段寄存器访问。\n\n------\n\n### **5. 如何绕过 Canary？**\n\n尽管 Canary 是有效的防护措施，但仍有潜在绕过方法：\n\n#### **5.1 信息泄漏（Information Leak）**\n\n- **原理**：通过漏洞（如格式化字符串漏洞）泄漏 Canary 值。\n- **防御**：将 Canary 值存储在不可读的内存区域（现代系统已实现）。\n\n#### **5.2 覆盖其他指针**\n\n- **原理**：不覆盖返回地址，而是劫持函数指针或异常处理机制（如 SEH）。\n- **防御**：结合其他防护（如 ASLR、CFG）。\n\n#### **5.3 逐字节爆破（Brute Force）**\n\n- **原理**：在 fork 型服务中，通过多次尝试猜测 Canary 值。\n- **防御**：使用足够长的随机 Canary（如 64 位）。\n\n------\n\n### **6. 实际应用**\n\n#### **6.1 编译器选项**\n\n- **GCC/Clang**：通过 `-fstack-protector` 启用 Canary（`-fno-stack-protector` 禁用）。\n- **MSVC**：通过 `/GS` 编译选项启用。\n\n#### **6.2 检查是否启用 Canary**\n\n在二进制中，可以通过以下特征识别：\n\n- **函数序言**：存在 `mov reg, fs:0x28` 指令。\n- **函数尾声**：存在 `xor reg, fs:0x28` 和检查跳转。\n\n------\n\n### **7. 总结**\n\n- **优点**：高效、低开销，能防御大多数栈溢出攻击。\n- **缺点**：无法防御堆溢出或非栈溢出漏洞。\n- **最佳实践**：需结合其他防护（如 ASLR、DEP、CFI）。\n\nCanary 值是现代软件安全的基石之一，理解其原理对逆向工程、漏洞分析和防御设计至关重要。\n\n# .BSS、.data和.text\n\nhttps://blog.csdn.net/SXXYNHHXX/article/details/142489025?fromshare=blogdetail&sharetype=blogdetail&sharerId=142489025&sharerefer=PC&sharesource=2401_88035404&sharefrom=from_link\n\nhttps://blog.csdn.net/m0_56573171/article/details/128153152?fromshare=blogdetail&sharetype=blogdetail&sharerId=128153152&sharerefer=PC&sharesource=2401_88035404&sharefrom=from_link\n\n# static\n\nhttps://blog.csdn.net/2302_76305195/article/details/132035585?fromshare=blogdetail&sharetype=blogdetail&sharerId=132035585&sharerefer=PC&sharesource=2401_88035404&sharefrom=from_link\n"},{"title":"happy~","url":"/2025/02/07/3/"},{"title":"hell0~","url":"/2025/02/04/4/","content":"\n## [WUSTCTF2020]Cr0ssfun\n\n## 查壳\n\n64位ELF文件\n\n![](fun1.png)\n\n## 反编译\n\n![](fun2.png)\n\n分析可以知道将V4转化为64位整数类型，进入check函数，check函数的返回值被转化为unsigned int 类，如果返回值为1，输出Your flag is correct, go and submit it!\n\n跟进check函数\n\n![](fun3.png)\n\n继续跟进就ok了\n\n![](fun4.png)\n\n![](fun5.png)\n\n![](fun6.png)\n\n![](fun7.png)\n\n![](fun8.png)\n\n![](fun9.png)\n\n按照下标将他们组合起来就得到flag``ctf2020{cpp_@nd_r3verse_@re_fun}``\n\n## 脚本\n\n感觉我做的好麻烦，去网上看看，同样很麻烦，顺了个没啥用的脚本\n\n```\n#include<iostream>\nusing namespace std;\nint main()\n{\n\tchar a1[32];\n\ta1[1] = 'c';a1[25] ='@' ; a1[27] = 'e';\n\t  a1[4] = '2';\n      a1[17] = 'r';\n       a1[29] = 'f';\n       a1[17]= 'r';\n       a1[24] = '_';\n       a1[2] = 't';\n       a1[9] = 'c';\n       a1[32] = '}';\n       a1[19] = 'v';\n       a1[5] = '0';\n       a1[14] = 'n';\n        a1[15] = 'd';\n       a1[8] ='{';\n       a1[18] = '3';\n       a1[28] = '_';\n       a1[21] = 'r';\n        a1[0] = 'w';\n      a1[6] = '2';\n       a1[22] = 's';\n       a1[31] = 'n';\n       a1[12] = '_';\n        a1[7] = '0';\n       a1[16] = '_';\n       a1[11] = 'p';\n       a1[23] = 'e';\n       a1[30] = 'u';\n    \ta1[10] = 'p';\n       a1[13] = '@';\n       a1[3] = 'f';\n       a1[26] = 'r';\n      a1[20] = 'e';\n      for(int i=0;i<=32;i++)cout << a1[i];  \n}\n\n```\n\n# [UTCTF2020]basic-re\n\n## 查壳\n\n64位无壳文件\n\n![](base1.png)\n\n## 关键信息&反编译\n\nshift+F12查找字符串发现好多关键词，进去看看\n\n得到mTyqm7wjODkrNLcWl0eqO8K8gc1BPk1GNLgUpI==\n\n``base64Encode( )``进去看看吧\n\n![](base2.png)\n\nbase编码过程，从其中找到编码表\n\n![](base3.png)\n\nAaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0987654321/+\n\n![](base4.png)\n\n## 解密\n\n把他们扔进CyberChef\n\n![](base5.png)\n\n# [GWCTF 2019]xxor\n\n## 查壳\n\n64位ELF文件\n\n![](xxor0.png)\n\n## 查找关键信息\n\nshift+F12查找关键字Congratulation!点进去看看吧\n\n![](xxor1.png)\n\n## 反编译\n\n主要函数\n\n``sub_400770(v7, a2) = 1``输出成功信息\n\n``LODWORD(v7[j]) = dword_601078;``用于提取一个 64 位变量的低 32 位\n``HIDWORD(v7[j]) = dword_60107C;``用于提取一个 64 位变量的高 32 位\n\n\n\n![](xxor2.png)\n\n深入sub_400686函数，发现只要获得其中需要的数据就可以逆向得到答案\n\n![](xxor3.png)\n\n这是那个判断函数，从中就可以获得上面需要的信息\n\n![](xxor4.png)\n\n用前几天学过的z3\n\n```\nfrom z3 import *\na1=[0]*6\na1[0],a1[1],a1[2],a1[3],a1[4],a1[5]=Ints('a1[0] a1[1] a1[2] a1[3] a1[4] a1[5]')\ns = Solver()\ns.add(a1[2] - a1[3]== 2225223423)\ns.add(a1[3] + a1[4]== 4201428739)\ns.add(a1[2] - a1[4]==1121399208)\ns.add(a1[0] ==-548868226)\ns.add(a1[5] == -2064448480)\ns.add(a1[1] == 550153460)\nif s.check()==sat:\n    r=s.model()\nprint(r)\n```\n\n解密 ，然后再十六进制转化成字符串，得到flag\n\n```\n#include <stdio.h>\nint main() {\nunsigned int a2[4] = {2,2,3,4};\nunsigned int a1[6] = { 3746099070,550153460, 3774025685 ,1548802262 ,2652626477 ,2230518816 };\nunsigned int flag[6];\nunsigned v3, v4;\nunsigned int i,j;\nfor (j = 0; j < 6; j+=2)\n{\nv3 = a1[j];\nv4 = a1[j+1];\nunsigned long long int tem = (unsigned long long int)0x458BCD42 * 64;\nunsigned int sum = (unsigned int) tem;\nfor(i = 0; i < 64; i++)\n{\nv4 -= (v3 + sum + 20) ^ ((v3 << 6) + a2[2]) ^ ((v3 >> 9) + a2[3]) ^ 16;\nv3 -= (v4 + sum + 11) ^ ((v4 << 6) + a2[0]) ^ ((v4 >> 9) + a2[1]) ^ 32;\nsum -= 0x458BCD42;\n}\nflag[j] = v3;\nflag[j + 1] = v4;\n}\nfor (int n = 0; n < 6; n++)\nprintf(\"%x\", flag[n]);\nreturn 0;\n}\n```\n\n\n\n# 文件格式\n\n## **1. ELF（Executable and Linkable Format）**\n\n- **使用平台**：Linux、Unix、类Unix系统（如FreeBSD、Android）。\n- **特点**：\n  - 支持多种架构（如x86、ARM、RISC-V）。\n  - 支持动态链接和静态链接。\n  - 结构清晰，包含ELF头、程序头表、节头表。\n  - 常用于可执行文件、共享库（.so）、目标文件（.o）和核心转储。\n- **工具**：`readelf`、`objdump`、`nm`。\n- **文件扩展名**：`.elf`、`.so`、`.o`。\n\n------\n\n## **2. PE（Portable Executable）**\n\n- **使用平台**：Windows。\n- **特点**：\n  - 基于COFF（Common Object File Format）扩展。\n  - 支持32位（PE32）和64位（PE32+）。\n  - 包含DOS头、PE头、节表、导入表、导出表等。\n  - 支持动态链接（DLL文件）和资源管理（如图标、菜单）。\n- **工具**：`dumpbin`、`PEview`、`CFF Explorer`。\n- **文件扩展名**：`.exe`、`.dll`、`.sys`。\n\n------\n\n## **3. Mach-O（Mach Object）**\n\n- **使用平台**：macOS、iOS。\n- **特点**：\n  - 支持多种架构（如x86、ARM）。\n  - 包含Mach-O头、加载命令、段和节。\n  - 支持动态链接（dylib）和框架（Framework）。\n  - 支持代码签名和沙盒机制。\n- **工具**：`otool`、`nm`、`lipo`。\n- **文件扩展名**：`.o`、`.dylib`、`.app`。\n\n### 1. **提取特定位**\n\n通过掩码操作，可以从数据中提取特定位。例如，提取一个字节的低4位：\n\n```\nbyte = 0b10101100\nmask = 0b00001111\nresult = byte & mask  # 结果为 0b00001100\n```\n\n### 2. **设置特定位**\n\n掩码操作可以设置数据中的特定位。例如，设置一个字节的第3位：\n\n```\nbyte = 0b10101100\nmask = 0b00000100\nresult = byte | mask  # 结果为 0b10101100\n```\n\n### 3. **清除特定位**\n\n掩码操作可以清除数据中的特定位。例如，清除一个字节的第5位：\n\n```\nbyte = 0b10101100\nmask = ~0b00100000\nresult = byte & mask  # 结果为 0b10001100\n```\n\n### 4. **切换特定位**\n\n掩码操作可以切换数据中的特定位。例如，切换一个字节的第2位：\n\n```\nbyte = 0b10101100\nmask = 0b00000010\nresult = byte ^ mask  # 结果为 0b10101110\n```\n\n### 5. **检查特定位**\n\n掩码操作可以检查数据中的特定位是否被设置。例如，检查一个字节的第7位：\n\npython\n\n复制\n\n```\nbyte = 0b10101100\nmask = 0b10000000\nif byte & mask:\n    print(\"第7位被设置\")\nelse:\n    print(\"第7位未被设置\")\n```\n\n### 6. **组合掩码**\n\n多个掩码可以组合使用。例如，提取一个字节的第2位和第4位：\n\n```\nbyte = 0b10101100\nmask = 0b00001010\nresult = byte & mask  # 结果为 0b00001000\n```\n\n### 7. **移位操作**\n\n移位操作常与掩码操作结合使用。例如，提取一个32位整数的第5到第8位：\n\n```\nvalue = 0x12345678\nmask = 0x000000F0\nresult = (value & mask) >> 4  # 结果为 0x00000005\n```\n\n# Std库\n\n### **1. 容器（Containers）**\n\n用于存储和管理数据的模板类，分为：\n\n- **顺序容器**：按顺序存储元素。\n  - `vector`：动态数组。\n  - `list`：双向链表。\n  - `deque`：双端队列。\n  - `array`：固定大小数组（C++11）。\n  - `forward_list`：单向链表（C++11）。\n- **关联容器**：基于键值对的有序/无序集合。\n  - `set`/`multiset`：有序唯一/重复集合。\n  - `map`/`multimap`：有序键值对。\n  - `unordered_set`/`unordered_multiset`：哈希表实现的集合（C++11）。\n  - `unordered_map`/`unordered_multimap`：哈希表实现的键值对（C++11）。\n- **容器适配器**：基于其他容器实现的接口。\n  - `stack`：后进先出（LIFO）栈。\n  - `queue`：先进先出（FIFO）队列。\n  - `priority_queue`：优先级队列。\n\n```\n#include <vector>\nstd::vector<int> nums = {1, 2, 3};\n```\n\n------\n\n### **2. 算法（Algorithms）**\n\n提供通用算法，通过 `<algorithm>` 头文件访问：\n\n- **非修改序列操作**：`for_each`, `find`, `count`。\n- **修改序列操作**：`copy`, `fill`, `replace`。\n- **排序和查找**：`sort`, `binary_search`, `lower_bound`。\n- **数值操作**：`accumulate`, `inner_product`（需 `<numeric>`）。\n\n```\n#include <algorithm>\nstd::sort(nums.begin(), nums.end());\n```\n\n------\n\n### **3. 字符串处理（Strings）**\n\n- `std::string`：动态字符串类，支持拼接、查找、替换等操作。\n- `std::string_view`：字符串视图（C++17），用于高效读取字符串片段。\n\n```\nstd::string s = \"Hello\";\ns.append(\" World\");\n```\n\n------\n\n### **4. 输入/输出（I/O）**\n\n通过 `<iostream>`、`<fstream>` 等头文件提供：\n\n- **流对象**：`std::cin`, `std::cout`, `std::cerr`, `std::clog`。\n- **文件操作**：`std::ifstream`, `std::ofstream`。\n- **格式化工具**：`std::hex`, `std::setw`, `std::fixed`（需 `<iomanip>`）。\n\n```\n#include <iostream>\nstd::cout << \"Value: \" << 42 << std::endl;\n```\n\n------\n\n### **5. 智能指针（Smart Pointers）**\n\n用于自动内存管理（需 `<memory>`）：\n\n- `std::unique_ptr`：独占所有权的指针。\n- `std::shared_ptr`：共享所有权的指针。\n- `std::weak_ptr`：解决 `shared_ptr` 循环引用问题。\n\n```\nauto ptr = std::make_unique<int>(42);\n```\n\n------\n\n### **6. 工具类与函数（Utilities）**\n\n- **元编程**：`std::pair`, `std::tuple`, `std::variant`（C++17）。\n- **类型操作**：`std::move`（移动语义）, `std::forward`（完美转发）。\n- **时间和日期**：`std::chrono`（需 `<chrono>`）。\n- **随机数生成**：`std::mt19937`（需 `<random>`）。\n\n```\nstd::pair<int, std::string> p = {1, \"one\"};\n```\n\n------\n\n### **7. 多线程与并发（Concurrency）**\n\n通过 `<thread>`, `<mutex>`, `<atomic>` 等头文件支持：\n\n- 线程管理：`std::thread`, `std::jthread`（C++20）。\n- 同步机制：`std::mutex`, `std::lock_guard`, `std::condition_variable`。\n- 原子操作：`std::atomic<T>`。\n\n```\n#include <thread>\nstd::thread t([](){ std::cout << \"Thread!\"; });\nt.join();\n```\n\n------\n\n### **8. 异常处理（Exceptions）**\n\n- 异常类：`std::exception` 及其子类（如 `std::runtime_error`）。\n- 异常工具：`std::throw_with_nested`（C++11）。\n\n```\ntry {\n    throw std::runtime_error(\"Error!\");\n} catch (const std::exception& e) {\n    std::cerr << e.what();\n}\n```\n\n------\n\n### **9. 其他重要组件**\n\n- **函数对象**：`std::function`（包装函数指针、Lambda 等）。\n- **正则表达式**：`std::regex`（需 `<regex>`）。\n- **文件系统操作**：`std::filesystem`（C++17，需 `<filesystem>`）。\n\n```\n#include <functional>\nstd::function<int(int, int)> add = [](int a, int b) { return a + b; };\n```\n"},{"title":"study","url":"/2025/01/27/2/","content":"\n# [GDOUCTF 2023]Check_Your_Luck\n\n![](z3求解0.png)\n\nz3求解,第一次见查一查，挺简单的，写个脚本吧\n\n![](z3求解2.png)\n\n# 相册\n\n## APK文件，使用jadx-gui打开\n\n## 查找关键词邮箱(mail)\n\n发现一个静态方法`sendMailByJavaMail`(用于通过 JavaMail API 发送电子邮件)\n\n![](相册1.png)\n\n右击查找用例\n\n![](相册2.png)\n\n![](相册3.png)\n\n表示调用 `A2` 类中的静态方法 (判断：方法名前面有类名)`sendMailByJavaMail`\n\n![](相册4.png)\n\n他接受了三个参数\n\n该方法接受三个参数：\n\n1. `C2.MAILSERVER`: 邮件服务器地址或配置。\n2. `\"通讯录(\" + tel + \"IMEI\" + imei + \")\"`: 邮件的主题。\n3. `notebooks`: 邮件的内容。\n\n跟进MAILSERVER\n\n![](相册5.png)\n\n用loadlibrary函数，加载了core.so文件中的内容\n\nbase64关键字\n\n跟进NativeMethod\n\n![](相册6.png)\n\n三个方法均返回字符串\n\n## 解压apk文件，访问libcore.so\n\n查壳，用IDA打开libcore.so\n\nshift+F12查找关键信息\n\nbase64编码\n\n![](相册7.png)\n\n解码得到flag\n\n![](相册9.png)\n\n# [BJDCTF 2020]JustRE\n\n## 查壳\n\n![](justre1.png)\n\nshift+F12查找关键词\n\n![](justre2.png)\n\n好像，追踪\n\n![](justre3.png)\n\n点击19999下给你flag,666这是要累死你，动态调试一下看看\n\n嗯，他就是这个意思end\n\n# Z3小知识\n\n![](z3求解1.png)\n\n```\nfrom z3 import *\na,b=Ints('a b')\ns=Solver() #创建一个约束求解器\ns.add(a+b==10) #添加约束条件\ns.add(a+3*b==12)\n\nif s.check()==sat: #有解\n    r=s.model() #求解\nprint(r) #[b = 1, a = 9]\nprint(r[a]) #9\nprint(r[b]) #1\n\n```\n\n# APK文件\n\nAPK（Android Package）是 Android 应用程序的安装包文件格式。它包含了应用程序的所有代码、资源、配置文件等。\n\n## **APK 文件结构**\n\nAPK 文件本质上是一个 ZIP 压缩包，包含以下主要文件和目录：\n\n- **`AndroidManifest.xml`**:\n  - 应用程序的配置文件，定义了应用的基本信息（如包名、版本号、权限、组件等）。\n  - 使用二进制 XML 格式存储，需要通过工具（如 `apktool`）反编译后才能查看。\n- **`classes.dex`**:\n  - 包含应用程序的 Java/Kotlin 代码编译后的 Dalvik 字节码。\n  - 可能包含多个 `.dex` 文件（如 `classes2.dex`），用于支持多 Dex 文件的应用。\n- **`resources.arsc`**:\n  - 编译后的资源索引表，存储了字符串、布局、样式等资源的映射关系。\n  - 通过资源 ID 快速定位资源。\n- **`res/`**:\n  - 包含应用程序的资源文件（如图片、布局文件、字符串等）。\n  - 子目录包括 `drawable/`、`layout/`、`values/` 等。\n  - **`assets/`**:\n    - 存放原始资源文件（如字体、配置文件等），不会被编译到 `resources.arsc` 中。\n    - 通过 `AssetManager` 访问。\n  - **`lib/`**:\n    - 包含应用程序的本地库（如 `.so` 文件），通常按 CPU 架构分类（如 `armeabi-v7a`、`arm64-v8a`）。\n  - **`META-INF/`**:\n    - 包含应用的签名信息，用于验证 APK 的完整性和来源。\n    - 主要文件：\n      - `MANIFEST.MF`：列出所有文件的哈希值。\n      - `CERT.SF`：签名文件的哈希值。\n      - `CERT.RSA`：包含公钥和签名信息。\n\n## **APK 的反编译与修改**\n\n- **反编译工具**:\n  - `apktool`：反编译 APK，提取资源和 `AndroidManifest.xml`。\n  - `dex2jar`：将 `.dex` 文件转换为 `.jar` 文件，便于查看 Java 代码。\n  - `JD-GUI`：查看 `.jar` 文件中的 Java 代码。\n"},{"title":"是逆向啊","url":"/2025/01/23/heihei/","content":"#  [HNCTF 2022 WEEK2]e@sy_flower\n## 1.查壳选择合适IDA\n## 2.发现去除花指令\n#### 发现花指令\njnz+jz用连续两条相反的条件跳转，或是通过stc/clc汇编指令来设置位，使条件跳转变为永真或者永假跳转\n\n\n#### 将花指令nop\n\n\n\n![flower1](flower1.png)\n\nEdit-Patch program-Change bytes\n将E9改为90 \n![flower2](flower2.png)\n\n## 3.反编译\n找到main函数，在main函数之前摁P重定义\n![flower3](flower3.png)\nF5反编译\n![flower4](flower4.png)\n\n#### 函数的分析\n(1)Arglist中的字符两两交换位置（2n与2n+1交换）\n\n(2)Arglist中的每个字符与字符'0'进行异或操作\n## 4.脚本\n![flower5](flower5.png)\n嘿嘿嘿得到flag\n\n# [LitCTF 2023]ez_XOR\n## 1.查壳选IDA\n## 2.寻找关键字符\n#### shift+F12\n发现关键字并追踪\n![ez_xor0](ez_xor0.png)\n\n## 3.反编译\n![ez_xor](ez_xor.png)\n并不是到此处就可以直接写脚本了，点击XOR发现里面还有玄机\n![ez_xor1](ez_xor1.png)\n好了，现在可以写脚本了\n\n## 4.脚本\n![ez_xor2](ez_xor2.png)\n# 花指令的小知识\n## 形式一:\n如果我们插入的花指令是一个操作码，那么后面程序原本的机器码就会被误认为是这个操作码的操作数，从而导致反汇编引擎的解析错误。\n\n## 形式二：\n插入的花指令也可以是改变堆栈平衡的汇编代码，跟形式一相同在这些花指令上面写上跳转指令，虽然花指令不会被执行，但是IDA进行解析时会认为该函数堆栈不平衡，从而使F5功能失效\n\n# 保持堆栈的平衡\npush ebp ---  -把基址指针寄存器压入堆栈\npop ebp ----把基址指针寄存器弹出堆栈\npush eax ----把数据寄存器压入堆栈\npop eax ----把数据寄存器弹出堆栈\nnop -----不执行\nadd esp,1-----指针寄存器加1\nsub esp,-1-----指针寄存器加1\nadd esp,-1--------指针寄存器减1\nsub esp,1-----指针寄存器减1\ninc ecx -----计数器加1\ndec ecx -----计数器减1\nsub esp,1 ----指针寄存器-1\nsub esp,-1----指针寄存器加1\njmp 入口地址----跳到程序入口地址\npush 入口地址---把入口地址压入堆栈\nretn ------ 反回到入口地址,效果与jmp 入口地址一样\nmov eax,入口地址 ------把入口地址转送到数据寄存器中.\njmp eax ----- 跳到程序入口地址\njb 入口地址\njnb 入口地址 ------效果和jmp 入口地址一样,直接跳到程序入口地址\nxor eax,eax 寄存器EAX清0\nCALL 空白命令的地址 无效call\n\n\n"},{"title":"Hello World","url":"/2025/01/16/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]